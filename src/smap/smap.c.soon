#include "../util.h"
#include <merlin/simd.h>
#include <merlin/smap.h>
#include <string.h>

// get the appropriate size for the buffer so that a user can insert up to
// capacity elements, * 8 / 7 is for later * 7 / 8 growing check
__attribute__((warn_unused_result, const)) static intptr_t
cap_to_bufsz(const intptr_t capacity) {
  let x = (capacity * 8) / 7;
  x = MAX(x, 16);
  x = 1 << (sizeof(long long) * 8 - __builtin_clzll(x) + 1);
  return x;
}

__attribute__((warn_unused_result, const)) static intptr_t
bufsz_to_chnksz(const intptr_t sz) {
  return sizeof(mrln_str8view_t) * sz + sizeof(uintptr_t) * sz +
         sizeof(uint8_t) * (sz + 32);
}

__attribute__((nonnull(1), warn_unused_result, const)) static mrln_str8view_t *
keybuf(const mrln_smap_t *t) {
  return (void *)(t->_ctrl + 32 + t->_bufsz);
}

__attribute__((nonnull(1), warn_unused_result, const)) static uintptr_t *
valbuf(const mrln_smap_t *t) {
  return (void *)((uint8_t *)keybuf(t) + t->_bufsz * sizeof(*t->key));
}

__attribute__((nonnull(1, 3), warn_unused_result("returns an error code"))) int
mrln_smap(mrln_smap_t *t, const intptr_t capacity, mrln_aloctr_t *a) {
  t->_bufsz = cap_to_bufsz(capacity);

  let err = mrln_alloc(a, (void **)&t->_ctrl, &t->_chnksz, 32,
                       bufsz_to_chnksz(t->_bufsz));
  if (UNLIKELY(err)) {
    return err;
  }

  memset(t->_ctrl, 0, t->_bufsz + 32);
  t->len = 0;
  t->_tomb = 0;
  t->key = keybuf(t);
  t->val = valbuf(t);
  return 0;
}

__attribute__((const, warn_unused_result)) static u8 hash_to_ctrl(const u64 h) {
  return ((u8)(h >> 56) | (u8)0x80);
}

__attribute__((nonnull(1), warn_unused_result, const)) intptr_t
find(const mrln_smap_t *t, const mrln_str8view_t key, const u64 h) {
  const let mod = t->_bufsz - 1;
  intptr_t i = h & mod;

  const let ctrl = mrln_v32u8_set1(hash_to_ctrl(h));
  const let zero = mrln_v32u8_set1(0);

  for (intptr_t o = 32;; i = (i + o) & mod, ++o) {
    const let row = mrln_v32u8_load_unaligned((const void *)(t->_ctrl + i));
    const let t0 = mrln_v32u8_cmpeq(row, ctrl);
    const let t1 = mrln_v32u8_cmpeq(row, zero);
    const let t2 = mrln_v32u8_or(t0, t1);
    let m = mrln_v32u8_mask(t2);

    for (let j = i; m; ++j, m >>= 1) {
      const let ctz = __builtin_ctz(m);
      m >>= ctz;
      j += ctz;
      const let k = (i + j) & mod;
      if (t->_ctrl[k] == 0 || mrln_str8view_is_equal(&t->key[k], &key)) {
        return (i + j) & mod;
      }
    }
  }
}

__attribute__((const, warn_unused_result)) static u64
comp_hash(const mrln_str8view_t key);

__attribute__((nonnull(1, 3),
               warn_unused_result("returns an error code"))) static int
rehash_to(mrln_smap_t *t, const intptr_t bufsz, mrln_aloctr_t *a) {
  mrln_smap_t new = {
      .len = t->len,
      ._bufsz = bufsz,
  };

  // initilize new
  {
    let err = mrln_alloc(a, (void **)&new._ctrl, &new._chnksz, 32,
                         bufsz_to_chnksz(bufsz));
    if (UNLIKELY(err)) {
      return err;
    }
    (void)memset(new._ctrl, 0, new._bufsz + 32);
    new.key = keybuf(&new);
    new.val = valbuf(&new);
  }

  for (intptr_t i = 0; i < t->_bufsz; ++i) {
    if (!(t->_ctrl[i] & 0x80)) {
      continue;
    }
    const let h = comp_hash(t->key[i]);
    const let j = find(t, t->key[i], h);
    new._ctrl[j] = t->_ctrl[i];
    if (j < 32) {
      new._ctrl[new._bufsz + j] = t->_ctrl[i];
    }
    new.key[j] = t->key[i];
    new.val[j] = t->val[i];
  }

  (void)mrln_alloc(a, (void **)t->_ctrl, &t->_chnksz, 32, 0);
  *t = new;
  return 0;
}

__attribute__((nonnull(1, 3), warn_unused_result("returns an error code"))) int
mrln_smap_reserve(mrln_smap_t *t, const intptr_t capacity, mrln_aloctr_t *a) {
  const let bufsz = cap_to_bufsz(capacity);
  if (bufsz > t->_bufsz) {
    return rehash_to(t, bufsz, a);
  }
  return 0;
}

__attribute__((nonnull(1, 2), warn_unused_result("returns an error code"))) int
mrln_smap_shrink(mrln_smap_t *t, mrln_aloctr_t *a) {
  const let bufsz = cap_to_bufsz(t->len);
  if (bufsz < t->_bufsz) {
    return rehash_to(t, bufsz, a);
  }
  return 0;
}

__attribute__((nonnull(1), warn_unused_result, const)) bool
mrln_smap_contains(const mrln_smap_t *t, const mrln_str8view_t key) {
  const let i = mrln_smap_find(t, key);
  return t->_ctrl[i] & 0x8;
}

__attribute__((nonnull(1, 2),
               warn_unused_result("returns an error code"))) static int
grow_if(mrln_smap_t *t, mrln_aloctr_t *a) {
  if (t->len >= (t->_bufsz * 7) / 8) {
    return rehash_to(t, t->_bufsz * 2, a);
  }
  return 0;
}

__attribute__((nonnull(1, 4), warn_unused_result("returns an error code"))) int
mrln_smap_insert(mrln_smap_t *t, const mrln_str8view_t key, uintptr_t val,
                 mrln_aloctr_t *a) {
  const let err = grow_if(t, a);
  if (UNLIKELY(err)) {
    return err;
  }
  const let i = mrln_smap_find(t, key);

  if (!t->_ctrl[i]) {
    t->key[i] = key;
    t->len += 1;
  }
  t->val[i] = val;
  return 0;
}

__attribute__((nonnull(1, 3, 4),
               warn_unused_result("returns an error code"))) int
mrln_smap_upsert(mrln_smap_t *t, const mrln_str8view_t key, uintptr_t *val,
                 mrln_aloctr_t *a) {
  const let err = grow_if(t, a);
  if (UNLIKELY(err)) {
    return err;
  }
  const let i = mrln_smap_find(t, key);
  if (!t->_ctrl[i]) {
    t->len += 1;
    t->key[i] = key;
    t->val[i] = *val;
  }
  *val = t->val[i];
  return 0;
}

__attribute__((nonnull(1))) bool mrln_smap_remove(mrln_smap_t *t,
                                                  const mrln_str8view_t key) {
  const let i = mrln_smap_find(t, key);
  if (t->_ctrl[i] & 0x80) {
    t->len -= 1;
    t->_tomb += 1;
    t->_ctrl[i] = 1;
    return 1;
  }
  return 0;
}

__attribute__((nonnull(1))) void mrln_smap_clear(mrln_smap_t *t) {
  t->len = 0;
  (void)memset(t->_ctrl, 0, t->_bufsz + 32);
}

__attribute__((nonnull(1), const)) bool mrln_smap_isset(mrln_smap_t *t,
                                                        intptr_t i) {
  return t->_ctrl[i] & 0x80;
}

__attribute__((nonnull(1, 2, 3),
               warn_unused_result("returns an error code"))) int
mrln_smap_copy(mrln_smap_t *restrict dest, const mrln_smap_t *restrict src,
               mrln_aloctr_t *a) {
  let err =
      mrln_alloc(a, (void **)&dest->_ctrl, &dest->_chnksz, 32, src->_chnksz);
  if (UNLIKELY(err)) {
    return err;
  }
  (void)memcpy(dest->_ctrl, src->_ctrl, src->_chnksz);
  dest->len = src->len;
  dest->_bufsz = src->_bufsz;
  dest->_tomb = src->_tomb;
  dest->key = keybuf(dest);
  dest->val = valbuf(dest);
  return 0;
}
